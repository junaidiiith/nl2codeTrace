import abc, re, logging

from pathlib import Path

from datasets.SolutionMatrix import SolutionMatrix
from utility import FileUtil

log = logging.getLogger(__name__)

DATASETS_FOLDER = Path(__file__).parent


class Dataset(abc.ABC):
    """
    Subclasses represent the evaluation datasets
    """

    def __init__(self):
        self._solution_matrix = None
        
    def all_original_code_file_names(self):
        return [name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_code_filenames_file())]
    
    def all_original_req_file_names(self):
        return[name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_req_filenames_file())]
        
    def encoding(self):
        return "utf-8-sig"

    @abc.abstractmethod
    def num_original_links(self):
        """
        original number all possible req/code links
        """
        pass
    
    @abc.abstractmethod
    def _all_code_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def _all_req_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def name(self):
        pass
    
    @abc.abstractmethod
    def folder(self):
        pass
    
    @abc.abstractmethod
    def code_folder(self):
        pass
    
    @abc.abstractmethod
    def req_folder(self):
        pass
    
    @abc.abstractmethod
    def method_callgraph(self):
        """
        returns the precalculated method call graph dictionary
        """
        pass
    
    @abc.abstractmethod
    def method_callgraph_path(self):
        pass

    @abc.abstractmethod
    def class_callgraph_path(self):
        pass
    
    def solution_matrix(self):
        if self._solution_matrix is None:
            self._read_solution_matrix()
        return self._solution_matrix
    
    @abc.abstractmethod
    def _read_solution_matrix(self):
        pass
    
    @abc.abstractmethod
    def raw_call_graph_path(self):
        """
        Returns the path to the raw call graph file (generated by an external call graph parser)
        """
        pass

    @abc.abstractmethod
    def packages(self):
        """
        Lists the packages of the dataset.
        (needed for call graph generation to differentiate external classes)
        """
        pass

    @abc.abstractmethod
    def class_callgraph(self):
        pass
    
    @abc.abstractmethod
    def is_english(self):
        pass


class Etour(Dataset):
    ETOUR_FOLDER = DATASETS_FOLDER / "eTour"
    ETOUR_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "etour_solution_links_english.txt"
    ETOUR_ITAL_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "etour_solution_links_italian.txt"
    ETOUR_REQ_DIR = ETOUR_FOLDER / "req"
    ETOUR_CODE_DIR = ETOUR_FOLDER / "code"
    ETOUR_RAW_CALLGRAPH = ETOUR_FOLDER / "etour_raw_callgraph.txt"
    ETOUR_CLASS_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_class_callgraph.json"
    ETOUR_METHOD_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_method_callgraph.json"
    ETOUR_ALL_CODE_FILENAMES_FILE = ETOUR_FOLDER / "all_code_filenames.txt"
    ETOUR_ALL_REQ_FILENAMES_FILE = ETOUR_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Use case name(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Description(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Participating Actor(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Entry (Operator |Tourist )?conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Exit conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("^Quality Requirements(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flow of events(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)  # Should not match anything
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)  # Should not match anything
    
    def __init__(self, use_italian_solution_matrix=False):
        super().__init__()
        if use_italian_solution_matrix:
            self.ETOUR_SOLUTION_MATRIX_PATH = self.ETOUR_ITAL_SOLUTION_MATRIX_PATH

    def name(self):
        return "etour"
    
    def folder(self):
        return self.ETOUR_FOLDER
    
    def code_folder(self):
        return self.ETOUR_CODE_DIR
    
    def req_folder(self):
        return self.ETOUR_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.ETOUR_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ETOUR_ALL_REQ_FILENAMES_FILE
    
    def num_original_links(self):
        return 6728
    
    def method_callgraph(self):
        return FileUtil.read_from_json(self.ETOUR_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ETOUR_METHOD_CALLGRAPH_PATH

    def class_callgraph_path(self):
        return self.ETOUR_CLASS_CALLGRAPH_PATH

    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_txt_format_solution_matrix(self.ETOUR_SOLUTION_MATRIX_PATH)
    
    def italian_solution_matrix(self):  # Code file names are italian 
        return read_txt_format_solution_matrix(self.ETOUR_ITAL_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.ETOUR_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_from_json(self.ETOUR_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["beans", "com.trapan", "unisa.gps"]
    
    def is_english(self):
        return True


class Itrust(Dataset):
    
    ITRUST_FOLDER = DATASETS_FOLDER / "iTrust"
    ITRUST_SOLUTION_MATRIX_PATH = ITRUST_FOLDER / "itrust_solution_links.txt"
    ITRUST_REQ_DIR = ITRUST_FOLDER / "req"
    ITRUST_CODE_DIR = ITRUST_FOLDER / "code"
    ITRUST_RAW_CALLGRAPH = ITRUST_FOLDER / "itrust_raw_callgraph.txt"
    ITRUST_CLASS_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_class_callgraph.json"
    ITRUST_METHOD_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_method_callgraph.json"
    ITRUST_ALL_CODE_FILENAMES_FILE = ITRUST_FOLDER / "all_code_filenames.txt"
    ITRUST_ALL_REQ_FILENAMES_FILE = ITRUST_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "itrust"
    
    def num_original_links(self):
        return 29606
    
    def folder(self):
        return self.ITRUST_FOLDER
    
    def code_folder(self):
        return self.ITRUST_CODE_DIR
    
    def req_folder(self):
        return self.ITRUST_REQ_DIR

    def _all_code_filenames_file(self):
        return self.ITRUST_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ITRUST_ALL_REQ_FILENAMES_FILE

    def method_callgraph(self):
        return FileUtil.read_from_json(self.ITRUST_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ITRUST_METHOD_CALLGRAPH_PATH

    def class_callgraph_path(self):
        return self.ITRUST_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_txt_format_solution_matrix(self.ITRUST_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.ITRUST_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_from_json(self.ITRUST_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["edu.ncsu.csc.itrust"]

    def is_english(self):
        return True


class Smos(Dataset):
    
    SMOS_FOLDER = DATASETS_FOLDER / "smos"
    SMOS_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "smos_solution_links_italian.txt"
    SMOS_ENGLISH_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "smos_solution_links_english.txt"
    SMOS_REQ_DIR = SMOS_FOLDER / "req"
    SMOS_CODE_DIR = SMOS_FOLDER / "code"
    SMOS_RAW_CALLGRAPH = SMOS_FOLDER / "smos_raw_callgraph.txt"
    SMOS_CLASS_CALLGRAPH_PATH = SMOS_FOLDER / "smos_class_callgraph.json"
    SMOS_METHOD_CALLGRAPH_PATH = SMOS_FOLDER / "smos_method_callgraph.json"
    SMOS_ALL_CODE_FILENAMES_FILE = SMOS_FOLDER / "all_code_filenames.txt"
    SMOS_ALL_REQ_FILENAMES_FILE = SMOS_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Descrizione(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Precondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Postcondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)  # should never match -> smos doesn't have this element
    UC_USER_TEMPLATE_REGEX = re.compile("^Utente(:)?", re.RegexFlag.IGNORECASE)
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^Sistema(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Sequenza degli eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def __init__(self, use_english_solution_matrix=False):
        super().__init__()
        if use_english_solution_matrix:
            self.SMOS_SOLUTION_MATRIX_PATH = self.SMOS_ENGLISH_SOLUTION_MATRIX_PATH
            
    def name(self):
        return "smos"
    
    def num_original_links(self):
        return 6700
    
    def folder(self):
        return self.SMOS_FOLDER
    
    def code_folder(self):
        return self.SMOS_CODE_DIR
    
    def req_folder(self):
        return self.SMOS_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.SMOS_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.SMOS_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_from_json(self.SMOS_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.SMOS_METHOD_CALLGRAPH_PATH
    
    def class_callgraph_path(self):
        return self.SMOS_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_txt_format_solution_matrix(self.SMOS_SOLUTION_MATRIX_PATH)
    
    def english_solution_matrix(self):
        return read_txt_format_solution_matrix(self.SMOS_ENGLISH_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.SMOS_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_from_json(self.SMOS_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["smos"]
    
    def encoding(self):
        return "ISO-8859-1"

    def is_english(self):
        return False

    
class Eanci(Dataset):
    
    EANCI_FOLDER = DATASETS_FOLDER / "eANCI"
    EANCI_SOLUTION_MATRIX_PATH = EANCI_FOLDER / "eanci_solution_links.txt"
    EANCI_REQ_DIR = EANCI_FOLDER / "req"
    EANCI_CODE_DIR = EANCI_FOLDER / "code"
    EANCI_RAW_CALLGRAPH = EANCI_FOLDER / "eanci_raw_callgraph.txt"
    EANCI_CLASS_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_class_callgraph.json"
    EANCI_METHOD_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_method_callgraph.json"
    EANCI_ALL_CODE_FILENAMES_FILE = EANCI_FOLDER / "all_code_filenames.txt"
    EANCI_ALL_REQ_FILENAMES_FILE = EANCI_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome caso d'uso(:)?", flags=re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)  # should never match -> eAnci doesn't have this element
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori partecipanti(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Condizione di entrata(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Condizioni di uscita(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("Requisiti di qualita(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)  # should never match -> eAnci doesn't have this element
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)  # should never match -> eAnci doesn't have this element
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flusso di eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def name(self):
        return "eanci"
    
    def num_original_links(self):
        return 7645
    
    def folder(self):
        return self.EANCI_FOLDER
    
    def code_folder(self):
        return self.EANCI_CODE_DIR
    
    def req_folder(self):
        return self.EANCI_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.EANCI_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.EANCI_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_from_json(self.EANCI_METHOD_CALLGRAPH_PATH)

    def method_callgraph_path(self):
        return self.EANCI_METHOD_CALLGRAPH_PATH
    
    def class_callgraph_path(self):
        return self.EANCI_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_txt_format_solution_matrix(self.EANCI_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.EANCI_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_from_json(self.EANCI_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["DB", "Servlet", "Bean"]
        
    def encoding(self):
        return "ISO-8859-1"
    
    def is_english(self):
        return False

    
def read_txt_format_solution_matrix(file_path, delim=":"):
    """
    Use this for solution matrices of etour, libest, dronology
    """
    
    text_rows = []
    try:
        file = open(file_path, 'r', encoding='utf8')
        text_rows = file.readlines()
    except IOError:
        log.error("Unable to read " + str(file_path))
        
    tm = SolutionMatrix()
    for row in text_rows:
        row_split = row.split(delim)
        if row_split[1]:
            req_name = row_split[0]
            code_names = row_split[1].split()
            for code_name in code_names:
                tm.add_trace_pair(req_name, code_name)
        
    return tm
